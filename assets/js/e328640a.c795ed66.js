"use strict";(self.webpackChunkwhg_training_resources=self.webpackChunkwhg_training_resources||[]).push([[120],{3905:(e,n,t)=>{t.d(n,{Zo:()=>g,kt:()=>m});var o=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,s=function(e,n){if(null==e)return{};var t,o,s={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=o.createContext({}),u=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},g=function(e){var n=u(e.components);return o.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},c=o.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,l=e.parentName,g=i(e,["components","mdxType","originalType","parentName"]),c=u(t),m=s,h=c["".concat(l,".").concat(m)]||c[m]||p[m]||a;return t?o.createElement(h,r(r({ref:n},g),{},{components:t})):o.createElement(h,r({ref:n},g))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var a=t.length,r=new Array(a);r[0]=c;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var u=2;u<a;u++)r[u]=t[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}c.displayName="MDXCreateElement"},8128:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>u});var o=t(7462),s=(t(7294),t(3905));const a={sidebar_position:10},r="How much of the genome is in genes?",i={unversionedId:"programming/programming_with_gene_annotations/How_much_of_the_genome_is_in_genes",id:"programming/programming_with_gene_annotations/How_much_of_the_genome_is_in_genes",title:"How much of the genome is in genes?",description:"Up to table of contents",source:"@site/docs/programming/programming_with_gene_annotations/How_much_of_the_genome_is_in_genes.md",sourceDirName:"programming/programming_with_gene_annotations",slug:"/programming/programming_with_gene_annotations/How_much_of_the_genome_is_in_genes",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/How_much_of_the_genome_is_in_genes",draft:!1,editUrl:"https://github.com/whg-training/whg-training-resources/edit/main/docs/programming/programming_with_gene_annotations/How_much_of_the_genome_is_in_genes.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Getting sequence lengths",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/Getting_sequence_lengths"},next:{title:"Scaling up for a real analysis",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/Scaling_up"}},l={},u=[{value:"Union of regions",id:"union-of-regions",level:2},{value:"So how much of the genome is in genes?",id:"so-how-much-of-the-genome-is-in-genes",level:2},{value:"How much of the genome is in exons?",id:"how-much-of-the-genome-is-in-exons",level:3},{value:"How much of the genome is in coding sequence?",id:"how-much-of-the-genome-is-in-coding-sequence",level:3},{value:"Conclusions",id:"conclusions",level:3},{value:"Where next?",id:"where-next",level:2}],g={toc:u};function p(e){let{components:n,...a}=e;return(0,s.kt)("wrapper",(0,o.Z)({},g,a,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"how-much-of-the-genome-is-in-genes"},"How much of the genome is in genes?"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/"},"Up to table of contents")),(0,s.kt)("p",null,"To figure out how much of the genome is covered by genes, or by exons, we face a problem.\nIn principle we could just add together the gene lengths."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"genes['length'] = genes['end'] - genes['start']\ngenes.groupby('analysis').agg(\n    covered_length = pandas.NamedAgg( column = 'length', aggfunc = lambda w: w.sum() )\n)\n")),(0,s.kt)("p",null,"Then we could compare to the sequence lengths"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'sequence_lengths = pandas.read_sql( "SELECT analysis, SUM(end-start) AS sequence_length FROM sequences GROUP BY analysis", db )\n')),(0,s.kt)("p",null,"So this would say for example that about 44% of the human genome is covered by genes."),(0,s.kt)("h2",{id:"union-of-regions"},"Union of regions"),(0,s.kt)("p",null,"Unfortunately this isn't so simple - because many genes overlap each other. This happens either\nbecause there genuinely are different genes encoded by the same bit of DNA, or because of\nadditional annotated 'genes' that arise due to the computational gene annotation process. (We saw\none earlier - ",(0,s.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/Counting_genes_3"},"a tiny annotated gene inside ",(0,s.kt)("em",{parentName:"a"},"SLC4A2")),".)"),(0,s.kt)("p",null,"To handle this we have to compute the regions covered by a bunch of overlapping genes, and for that\nwe need to be able to compute this overlap."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Challenge."),". Write a function ",(0,s.kt)("inlineCode",{parentName:"p"},"compute_union_of_regions()")," that computes the total region covered\nby a set of (possibly overlapping ranges). Both the input and output should be a list of pairs of\nthe form ",(0,s.kt)("inlineCode",{parentName:"p"},"[ start, end ]")," (where ",(0,s.kt)("inlineCode",{parentName:"p"},"end")," >= ",(0,s.kt)("inlineCode",{parentName:"p"},"start")," and the coordinates are all non-negative\nintegers. The output should contain a set of non-overlapping ranges that cover the same set of\npositions as the input ranges. And for testability reasons, let's also require the output to be\nsorted (by the region start position)."),(0,s.kt)("p",null,"Here is a test:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"class TestRanges(unittest.TestCase):\n    def test_union_of_ranges( self ):\n        # check some simple cases first\n        self.assertEqual( compute_union_of_regions( [[1,10]] ) == [[1,10]] )\n        self.assertEqual( compute_union_of_regions( [] ) == [] )\n        self.assertEqual( compute_union_of_regions( [[1,10], [11,11]] ) == [[1,11]] )\n\n        test_data = [\n            [1, 10],\n            [19,199],\n            [5, 6],\n            [9, 15],\n            [20, 25]\n        ]\n        result = compute_union_of_ranges( test_data )\n        self.assertEqual( len( result ), 2 )\n        self.assertEqual( result[0] = [ 1, 15 ] )\n        self.assertEqual( result[1] = [ 19, 15 ] )\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Hints.")," "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"First ",(0,s.kt)("a",{parentName:"li",href:"https://docs.python.org/3/howto/sorting.html"},"sort the list of regions by the start point"),".\n(But be aware that python functions can mutate their arguments). You may want to use the ",(0,s.kt)("inlineCode",{parentName:"li"},"sorted()")," function rather than sorting\nin-place.\n"),(0,s.kt)("li",{parentName:"ul"},"Now traverse the list of regions, keeping track of the current interval and extending it if\nnecessary when you encounter overlapping input regions.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Important note.")," The coordinates in the GFF file are defined to ",(0,s.kt)("a",{parentName:"p",href:"http://www.ensembl.org/info/website/upload/gff.html"},"follow the 1-based\nconvention"),". This means that the genome\ncoordinates start at 1, and also that regions are defined to be closed - i.e. they contain both\ntheir endpoints. A region like ","[1,10]"," therefore contains 10 base positions."),(0,s.kt)("p",null,"(If this sounds obvious, I'm raising it because in other contexts a 0-based, half-open convention is\nused instead (in which the region [1,10) would contain only 9 positions, and would miss the 1st\ngenome location at zero). This is true for [the database that underlies the ",(0,s.kt)("a",{parentName:"p",href:"https://genome-blog.soe.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/"},"UCSC Genome\nBrowser"),"\nfor example (but not the browser itself, which converts coordinates to 1-based), and is\ncommon in programming generally.)"),(0,s.kt)("p",null,"My solution is ",(0,s.kt)("a",{target:"_blank",href:t(4003).Z},"here"),"."),(0,s.kt)("h2",{id:"so-how-much-of-the-genome-is-in-genes"},"So how much of the genome is in genes?"),(0,s.kt)("p",null,"We're ready to answer this! Let's use the above to write function that counts the bases covered in each genome:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'# Add this to your gff.py file\ndef compute_genome_bases_covered( regions, sequences ):\n   """Given a set of regions (as a dataframe with analysis, seqid, and start, and end columns),\n   and a set of sequences (as a dataframe with analysis, seqid and sequence_length columns, return\n   a dataframe showing the total number and proportion of sequence bases covered by the regions in\n   each analysis."""\n   def sum_region_lengths( regions ):\n      # We convert from pandas to a list...\n      aslist = regions[[\'start\', \'end\']].values.tolist()\n      # ...compute the union using your function...\n      union = compute_union_of_regions( aslist )\n      # ...and sum to get the result.\n      result = sum( [ (region[1]-region[0]+1) for region in union ] )\n      # Finally, we return as a pandas.Series() object\n      # because this lets us name the output variable.\n      return pandas.Series(\n         sum( [ (region[1]-region[0]+1) for region in union ] ),\n         index = [\'bases_covered\']\n      )\n   def compute_bases_covered_in_one_chromosome( regions ):\n      return (\n         regions\n         .groupby( [ "analysis", "seqid" ])\n         .apply( sum_region_lengths )\n      )\n   def add_sequence_lengths( coverage, sequences ):\n      return pandas.merge(\n         coverage,\n         sequences,\n         left_on = [ "analysis", "seqid" ],\n         right_on = [ "analysis", "seqid" ]\n      )\n   def sum_over_chromosomes( coverage ):\n      result = coverage.groupby( "analysis" ).agg(\n         bases_covered = pandas.NamedAgg( column = "bases_covered", aggfunc = sum ),\n         sequence_length = pandas.NamedAgg( column = "sequence_length", aggfunc = sum )\n      )\n      result[\'proportion\'] = result[\'bases_covered\'] / result[\'sequence_length\']\n      return result\n   per_chromosome = add_sequence_lengths(\n      compute_bases_covered_in_one_chromosome( regions )\n   )\n   return sum_over_chromosomes( per_chromosome )\n')),(0,s.kt)("p",null,"The code above is a bit complex, but in short:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"it uses the ",(0,s.kt)("inlineCode",{parentName:"li"},"compute_union_of_regions()")," function to compute the sum of lengths of genes ",(0,s.kt)("em",{parentName:"li"},"in each\nchromosome and species"),"."),(0,s.kt)("li",{parentName:"ul"},"it then adds a column with the sequence lengths ",(0,s.kt)("a",{parentName:"li",href:"/whg-training-resources/programming/programming_with_gene_annotations/Getting_sequence_lengths"},"that we computed earlier")," to the result."),(0,s.kt)("li",{parentName:"ul"},"Finally it summarises over the whole genome for each species and returns the result.")),(0,s.kt)("p",null,"Let's try it out:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'import pandas, sqlite3, gff\ndb = sqlite3.connect( "genes.sqlite" )\ngenes = pandas.read_sql( """\n   SELECT analysis, ID, Parent, seqid, start, end, strand, Name, biotype\n   FROM gff_data\n   WHERE type == \'gene\'\n   AND biotype == \'protein_coding\'\n""", db\n)\nsequences = pandas.read_sql( "SELECT analysis, seqid, ( end - start ) AS sequence_length FROM sequences", db )\ngff.compute_genome_bases_covered( genes, sequences )\n')),(0,s.kt)("p",null,"This gives:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                                            bases_covered  sequence_length  proportion\nanalysis                                                                               \nAcanthochromis_polyacanthus.ASM210954v1.104      415285145        830196730    0.500225\nCamelus_dromedarius.CamDro2.104.chr.gff3         815783547       2052758671    0.397408\nGallus_gallus.GRCg6a.104                         480522985       1050156563    0.457573\nHomo_sapiens.GRCh38.104                         1298183323       3085194781    0.420778\nMus_musculus.GRCm39.104                         1046654226       2723431121    0.384315\nPan_troglodytes.Pan_tro_3.0.104.chr             1101889770       2967125051    0.371366\nPlasmoDB-54_Pfalciparum3D7                        18174434         23332823    0.778921\n")),(0,s.kt)("p",null,"So only 42% of the human genome is covered by protein-coding genes. This drops a bit in\nchimpanzees, while a colossal 78% of the ",(0,s.kt)("em",{parentName:"p"},"P.falciparum")," genome is in genes."),(0,s.kt)("h3",{id:"how-much-of-the-genome-is-in-exons"},"How much of the genome is in exons?"),(0,s.kt)("p",null,"Here we'd better be a bit careful to only get exons in protein-coding genes. Let's do it in python\nas follows (as usual this could be done in sql as well, if we wanted):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'transcripts = pandas.read_sql( """\n   SELECT analysis, ID, Parent, seqid, start, end\n   FROM gff_data WHERE type == \'mRNA\'\n""", db )\n\nexons = pandas.read_sql( """\n   SELECT analysis, ID, Parent, seqid, start, end\n   FROM gff_data WHERE type == \'exon\'\n""", db )\n\nprint( "%d transcripts, %d exons.\\n" % ( transcripts.shape[0], exons.shape[0] ))\n')),(0,s.kt)("p",null,"Now find just the transcripts that actually are protein-coding genes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"transcripts = transcripts[ transcripts['Parent'].isin( genes['ID'])]\nexons = exons[ exons['Parent'].isin( transcripts['ID'] ) ]\nprint( \"%d transcripts, %d exons.\\n\" % ( transcripts.shape[0], exons.shape[0] ))\n\ngff.compute_genome_bases_covered( exons, sequences )\n")),(0,s.kt)("p",null,"This gives:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                                             bases_covered  sequence_length  proportion\nanalysis                                                                               \nAcanthochromis_polyacanthus.ASM210954v1.104       64427980        830196730    0.077606\nCamelus_dromedarius.CamDro2.104.chr.gff3          44585999       2052758671    0.021720\nGallus_gallus.GRCg6a.104                          41635090       1050156563    0.039647\nHomo_sapiens.GRCh38.104                           85003514       3085194781    0.027552\nMus_musculus.GRCm39.104                           76703787       2723431121    0.028164\nPan_troglodytes.Pan_tro_3.0.104.chr               61897466       2967125051    0.020861\nPlasmoDB-54_Pfalciparum3D7                        16683959         23332823    0.715042\n")),(0,s.kt)("p",null,"For most genomes, even though a large proportion of genome is in genes, hardly any is in exons. But\nP.falciparum is different: we already saw it has ",(0,s.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/Counting_genes_3"},"lots of single-exon genes"),"\nand sure enough most of the genome is in these exons."),(0,s.kt)("h3",{id:"how-much-of-the-genome-is-in-coding-sequence"},"How much of the genome is in coding sequence?"),(0,s.kt)("p",null,"This is easy now:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'cds = pandas.read_sql( """\n   SELECT analysis, ID, Parent, seqid, start, end, strand, Name, biotype\n   FROM gff_data WHERE type == \'CDS\'\n""", db)\ncds = cds[ cds["Parent"].isin( transcripts[\'ID\'])]\ngff.compute_genome_bases_covered( cds, sequences )\n')),(0,s.kt)("p",null,"This gives:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                                             bases_covered  sequence_length  proportion\nanalysis                                                                               \nAcanthochromis_polyacanthus.ASM210954v1.104       37182784        830196730    0.044788\nCamelus_dromedarius.CamDro2.104.chr.gff3          31455083       2052758671    0.015323\nGallus_gallus.GRCg6a.104                          28472131       1050156563    0.027112\nHomo_sapiens.GRCh38.104                           35837191       3085194781    0.011616\nMus_musculus.GRCm39.104                           36746474       2723431121    0.013493\nPan_troglodytes.Pan_tro_3.0.104.chr               35836571       2967125051    0.012078\nPlasmoDB-54_Pfalciparum3D7                        12357002         23332823    0.529597\n")),(0,s.kt)("p",null,"In humans, only about half of the sequence in protein-coding gene exons actually codes for proteins - genes have a great deal of ",(0,s.kt)("em",{parentName:"p"},"untranslated sequence"),"."),(0,s.kt)("h3",{id:"conclusions"},"Conclusions"),(0,s.kt)("p",null,"Two really striking things jump out from this to me.  First, in many eukaryotic organisms, hardly any of the\ngenome is actually coding for protein. "),(0,s.kt)("p",null,"What is the rest doing? Well, we saw that some of it is in ",(0,s.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/Counting_genes_1"},"pseudogenes or\nencodes non-protein-coding RNAs"),". Quite a lot actually is functional ",(0,s.kt)("a",{parentName:"p",href:"https://doi.org/10.1038/nature11247"},"as\ndescribed in the ENCODE paper")," (at least in the limited sense that\nproteins bind there, as part of a general process of regulating gene expression). Some of it is viral DNA\nthat has been retro-transposed into the genome - such as the ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Retrotransposon"},"LINEs and SINEs in the human\ngenome"),".  Some is genuinely doing nothing. However, much\nof the function of even well-annotated genomes (like humans) is not known."),(0,s.kt)("p",null,"On the other hand, some organisms like malaria seem to be making use of a great deal of their\ngenome for making proteins. Quite why this is is also not known."),(0,s.kt)("h2",{id:"where-next"},"Where next?"),(0,s.kt)("p",null,"Here are some ",(0,s.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/Where_next"},"suggested next steps"),"."))}p.isMDXComponent=!0},4003:(e,n,t)=>{t.d(n,{Z:()=>o});const o=t.p+"assets/files/regions-243718f2d84581d7d2ad5611257c6bd6.py"}}]);