"use strict";(self.webpackChunkwhg_training_resources=self.webpackChunkwhg_training_resources||[]).push([[4162],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>c});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),l=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=l(e.components);return a.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),h=l(t),c=r,g=h["".concat(p,".").concat(c)]||h[c]||u[c]||o;return t?a.createElement(g,i(i({ref:n},m),{},{components:t})):a.createElement(g,i({ref:n},m))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},9388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=t(7462),r=(t(7294),t(3905));const o={sidebar_position:8},i="Counting genes II: types of protein-coding genes",s={unversionedId:"programming/programming_with_gene_annotations/Counting_genes_2",id:"programming/programming_with_gene_annotations/Counting_genes_2",title:"Counting genes II: types of protein-coding genes",description:"Up to table of contents",source:"@site/docs/programming/programming_with_gene_annotations/Counting_genes_2.md",sourceDirName:"programming/programming_with_gene_annotations",slug:"/programming/programming_with_gene_annotations/Counting_genes_2",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/Counting_genes_2",draft:!1,editUrl:"https://github.com/whg-training/whg-training-resources/edit/main/docs/programming/programming_with_gene_annotations/Counting_genes_2.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Memory issues and how to solve them",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/Memory_issues_and_how_to_solve_them"},next:{title:"Extremely big, small and complex genes",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/Counting_genes_3"}},p={},l=[{value:"What types of protein-coding gene are there?",id:"what-types-of-protein-coding-gene-are-there",level:2},{value:"What do genes look like?",id:"what-do-genes-look-like",level:2},{value:"What are all those species anyway?",id:"what-are-all-those-species-anyway",level:2},{value:"How complicated are protein-coding genes?",id:"how-complicated-are-protein-coding-genes",level:2},{value:"A sqlite approach",id:"a-sqlite-approach",level:2}],m={toc:l};function u(e){let{components:n,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"counting-genes-ii-types-of-protein-coding-genes"},"Counting genes II: types of protein-coding genes"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/"},"Up to table of contents")),(0,r.kt)("p",null,"If you've followed so far you will have code ",(0,r.kt)("inlineCode",{parentName:"p"},"gff.py")," that can parse a GFF file, and in the process\nwill pull out certain fields from the ",(0,r.kt)("inlineCode",{parentName:"p"},"attributes")," column. This includes the ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," attribute, the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Parent")," attribute that says how records are linked, and also the ",(0,r.kt)("inlineCode",{parentName:"p"},"biotype")," column and maybe also\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"Name")," (which contains gene names). In the ",(0,r.kt)("a",{parentName:"p",href:"http://ftp.ensembl.org/pub/current_gff3/"},"Ensembl\nfiles")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"biotype")," is useful because it tells us what\nkind of genes they are."),(0,r.kt)("p",null,"If you haven't already, please download the GFF files for some different species and run them\nthrough your ",(0,r.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/Converting_gff_to_sqlite"},"sqlite conversion program")," to get them into the\ndatabase. I'm going to assume you followed the suggestion to add a column that distinguishes the\ndifferent species - in my code this is called ",(0,r.kt)("inlineCode",{parentName:"p"},"analysis")," and I'll use that below."),(0,r.kt)("p",null,"(For reference my version of the code is at\n",(0,r.kt)("a",{target:"_blank",href:t(3563).Z},"solutions/part2/gff_to_sqlite.py"),"\nand\n",(0,r.kt)("a",{target:"_blank",href:t(2114).Z},"solutions/part2/gff.py")," - feel free to run that\ninstead, if needed.)"),(0,r.kt)("p",null,"This sqlite file is now in a good shape to start really exploring genes. First let's look at what ",(0,r.kt)("inlineCode",{parentName:"p"},"biotypes")," there are."),(0,r.kt)("h2",{id:"what-types-of-protein-coding-gene-are-there"},"What types of protein-coding gene are there?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sqlite> .mode column\nsqlite> .header on\nsqlite> .width 50 25 25\nsqlite> SELECT analysis, biotype, COUNT(*) FROM gff_data WHERE type=='gene' GROUP BY analysis, biotype ;\n")),(0,r.kt)("p",null,"With the current data I have this gives:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"analysis                                            biotype                    COUNT(*)                 \n--------------------------------------------------  -------------------------  -------------------------\nAcanthochromis_polyacanthus.ASM210954v1.104         IG_J_gene                  2                        \nAcanthochromis_polyacanthus.ASM210954v1.104         IG_V_gene                  4                        \nAcanthochromis_polyacanthus.ASM210954v1.104         TR_J_gene                  5                        \nAcanthochromis_polyacanthus.ASM210954v1.104         protein_coding             24016                    \nCamelus_dromedarius.CamDro2.104.chr.gff3            IG_C_gene                  1                        \nCamelus_dromedarius.CamDro2.104.chr.gff3            IG_V_gene                  13                       \nCamelus_dromedarius.CamDro2.104.chr.gff3            TR_C_gene                  1                        \nCamelus_dromedarius.CamDro2.104.chr.gff3            TR_J_gene                  5                        \nCamelus_dromedarius.CamDro2.104.chr.gff3            TR_V_gene                  3                        \nCamelus_dromedarius.CamDro2.104.chr.gff3            protein_coding             18896                    \nGallus_gallus.GRCg6a.104                            IG_V_gene                  98                       \nGallus_gallus.GRCg6a.104                            protein_coding             16568                    \nHomo_sapiens.GRCh38.104                             IG_C_gene                  14                       \nHomo_sapiens.GRCh38.104                             IG_D_gene                  37                       \nHomo_sapiens.GRCh38.104                             IG_J_gene                  18                       \nHomo_sapiens.GRCh38.104                             IG_V_gene                  145                      \nHomo_sapiens.GRCh38.104                             TEC                        1056                     \nHomo_sapiens.GRCh38.104                             TR_C_gene                  6                        \nHomo_sapiens.GRCh38.104                             TR_D_gene                  4                        \nHomo_sapiens.GRCh38.104                             TR_J_gene                  79                       \nHomo_sapiens.GRCh38.104                             TR_V_gene                  106                      \nHomo_sapiens.GRCh38.104                             polymorphic_pseudogene     49                       \nHomo_sapiens.GRCh38.104                             protein_coding             19937                    \nMus_musculus.GRCm39.104                             IG_C_gene                  13                       \nMus_musculus.GRCm39.104                             IG_D_gene                  19                       \nMus_musculus.GRCm39.104                             IG_J_gene                  14                       \nMus_musculus.GRCm39.104                             IG_LV_gene                 4                        \nMus_musculus.GRCm39.104                             IG_V_gene                  218                      \nMus_musculus.GRCm39.104                             TEC                        3238                     \nMus_musculus.GRCm39.104                             TR_C_gene                  8                        \nMus_musculus.GRCm39.104                             TR_D_gene                  4                        \nMus_musculus.GRCm39.104                             TR_J_gene                  70                       \nMus_musculus.GRCm39.104                             TR_V_gene                  144                      \nMus_musculus.GRCm39.104                             polymorphic_pseudogene     89                       \nMus_musculus.GRCm39.104                             protein_coding             21834                    \nPan_troglodytes.Pan_tro_3.0.104.chr                 IG_C_gene                  11                       \nPan_troglodytes.Pan_tro_3.0.104.chr                 IG_V_gene                  91                       \nPan_troglodytes.Pan_tro_3.0.104.chr                 TR_C_gene                  9                        \nPan_troglodytes.Pan_tro_3.0.104.chr                 TR_V_gene                  66                       \nPan_troglodytes.Pan_tro_3.0.104.chr                 protein_coding             21879                    \nPlasmoDB-54_Pfalciparum3D7                          protein_coding_gene        5318                     \n")),(0,r.kt)("p",null,"The various biotypes used by Ensembl are ",(0,r.kt)("a",{parentName:"p",href:"https://m.ensembl.org/info/genome/genebuild/biotypes.html"},"documented\nhere"),". As the above shows, the vast\nmajority of genes in the file are protein-coding genes. In each organism, however a few genes are\nlisted as ",(0,r.kt)("inlineCode",{parentName:"p"},"polymorphic_pseudogene"),". You can ",(0,r.kt)("a",{parentName:"p",href:"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3491395/"},"read more about pseudogenes\nhere"),". They are genes that are non-coding in\nthe reference sequence (due to a disabling mutation), but still code for proteins in some\nindividuals."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"IG_")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"TR_")," biotypes are also interesting: they are the 'constant', 'joining', and\n'variable' gene segments of immunuglobulin and T cell receptors. They do encode proteins, but via a\nyet more ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/V(D)J_recombination"},"complex process that involves somatic recombination to assemble the mature genes in B and\nT cells"),". These gene segments also lie in\nregions that are ",(0,r.kt)("a",{parentName:"p",href:"https://doi.org/10.1371/journal.pcbi.1009254"},"especially complex"),". "),(0,r.kt)("p",null,"(What are the ",(0,r.kt)("inlineCode",{parentName:"p"},"TEC")," genes?)"),(0,r.kt)("p",null,"However, the vast majority of the genes listed have type ",(0,r.kt)("inlineCode",{parentName:"p"},"protein_coding"),", and we will focus on\nthese in the rest of this tutorial."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note.")," Here is similar code to count genes across species in python:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"import pandas, sqlite3\ndb = sqlite3.connect( \"genes.sqlite\" )\ndata = pandas.read_sql( \"SELECT * FROM gff_data WHERE type IN ( 'gene' )\", db )\ndata.groupby( [ 'analysis', 'biotype' ] ).size()\n")),(0,r.kt)("h2",{id:"what-do-genes-look-like"},"What do genes look like?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Challenge.")," Pick a gene (say human ABO or FUT2) and investigate in detail using your file. (If you've followed so\nfar this will be in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Name")," column.) How many transcripts does it have? (Hint: find records with ",(0,r.kt)("inlineCode",{parentName:"p"},"Parent")," equal to\nthe gene ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),". (Are there any other records with the gene as parent, that aren't transcripts? What are they?). What is\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"transcript_support_level")," for transcripts, and what does that mean? Pick a transcript and look at its sub-records\n(again by matching the ",(0,r.kt)("inlineCode",{parentName:"p"},"Parent`` to the transcript "),"ID`). What types are they apart from exons? Can you see how this\ndata compares to the representation on ",(0,r.kt)("a",{parentName:"p",href:"http://www.ensembl.org/"},"Ensembl")," or on\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://genome.ucsc.edu"},"UCSC genome browser"),"?"),(0,r.kt)("h2",{id:"what-are-all-those-species-anyway"},"What are all those species anyway?"),(0,r.kt)("p",null,"If like me you're a bit unclear about what ",(0,r.kt)("a",{parentName:"p",href:"http://ftp.ensembl.org/pub/current_gff3/"},"all those\nspecies")," are, now might be a good time to go and look at\nthe ",(0,r.kt)("a",{parentName:"p",href:"http://www.onezoom.org"},"OneZoom Tree of Life explorer"),". This will tell you, for example, that\n",(0,r.kt)("em",{parentName:"p"},"Acanthochromis polyacanthus")," is a member of the ",(0,r.kt)("a",{parentName:"p",href:"http://www.onezoom.org/life/@Ovalentaria=5553750?img=best_any&anim=flight#x1307,y908,w1.5714"},"Sticky Eggs\nGroup"),"\nthat also includes Cichlids, Silversides and Guppies, or that ",(0,r.kt)("em",{parentName:"p"},"mus musculus")," is one of 37 species\ncollectively known as 'house mice'."),(0,r.kt)("h2",{id:"how-complicated-are-protein-coding-genes"},"How complicated are protein-coding genes?"),(0,r.kt)("p",null,"Let's count how many transcripts each gene has, and how many exons."),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Challenge")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Write python code that reads in the appropriate data from ",(0,r.kt)("inlineCode",{parentName:"p"},"gff_data")," table, and for\neach gene counts i. the number of transcripts and ii. the average number of exons (averaged over\nthe transcripts for that gene)."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Hints.")),(0,r.kt)("p",null,"To do this is a bit more involved than previous steps. You need to find a way to join the\ntranscript records to the genes, and the exon records to the transcripts. Here is one way:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Start by loading just the genes, transcripts, and exons into seperate data frames.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Write a function ",(0,r.kt)("inlineCode",{parentName:"p"},"count_exons_per_transcript()")," that takes the transcripts and exons, and\nreturns a dataframe of transcripts with a column that reports the number of exons.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Then similarly write a function ",(0,r.kt)("inlineCode",{parentName:"p"},"summarise_transcripts_per_gene()")," that takes the genes and the\nabove summarised transcripts, and returns a dataframe of transcripts with a column for the number\nof transcripts and a column for the average number of exons.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"There are a couple of ways to implement these functions. One way is to iterate through dataframes\nand build python data structures that capture the hierarchy of genes, transcripts, and exons.\nE.g. the first function might return something like this:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transcript_summary = [\n   {\n      "ID":"transcript:ENST00000641515",\n      "exons": [\n         "ENSE00003812156", "ENSE00003813641", "ENSE00003813949"\n      ]\n   },\n   ...\n}\n')),(0,r.kt)("p",null,"and the second function something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'gene_summary = {\n   "gene:ENSG00000186092": {\n      "number_of_transcripts": 1,\n      "average_number_of_exons": 3,\n      "transcripts": [\n         # array of objects recording transcripts and their exons\n         {\n            "ID":"transcript:ENST00000641515",\n            "exons": [\n               "ENSE00003812156", "ENSE00003813641", "ENSE00003813949"\n            ]\n         }\n      ]\n   },\n   ...\n}\n')),(0,r.kt)("p",null,"You would then iterate through the second object to compute the summaries."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A slicker way to implement this is to use 'data joins' and 'group by' operations. In pandas the\nfunctions to use are the ",(0,r.kt)("a",{parentName:"li",href:"https://pandas.pydata.org/docs/user_guide/merging.html"},(0,r.kt)("inlineCode",{parentName:"a"},"merge()\nfunction")),") and the\n",(0,r.kt)("a",{parentName:"li",href:"https://pandas.pydata.org/docs/user_guide/groupby.html"},(0,r.kt)("inlineCode",{parentName:"a"},"groupby()"))," function. A simple version\nof this is:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transcripts_and_exons = pandas.merge(\n    transcripts,\n    exons[ ["ID", "Parent" ]],\n    how = "outer",\n    left_on = "ID",\n    right_on = "Parent"\n)\ntranscript_summary = transcripts_and_exons.groupby( [\'ID_x\', \'Parent_x\'] ).count()\n')),(0,r.kt)("p",null,"This joins the transcripts to the exon IDs, and then groups the result by transcript to count the rows."),(0,r.kt)("p",null,'However the above has a few issues. First, gets the names wrong - "ID_x", "Parent_x" and so on, and\nthe third column does not even have a name! It is always good to have the right names. The\n',(0,r.kt)("inlineCode",{parentName:"p"},".rename()")," option and the 'Named aggregation' syntax described on the ",(0,r.kt)("a",{parentName:"p",href:"https://pandas.pydata.org/docs/user_guide/groupby.html"},(0,r.kt)("inlineCode",{parentName:"a"},"groupby()"),"\npage")," can be used to fix this. Something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"transcripts_and_exons.rename(\n   columns = { 'ID_x': 'ID', 'Parent_x': 'Parent', 'ID_y': 'exon_ID', 'Parent_y', 'exon_Parent' },\n   inplace = True\n)\n\ndef count( x ):\n   return len(x)\n\ntranscript_summary = (\n   transcripts_and_exons\n      .groupby( ['ID', 'Parent'] )\n      .agg(\n         number_of_exons = pandas.NamedAgg(\n            column = \"exon_ID\",\n            aggfunc = count\n         )\n      )\n)\n")),(0,r.kt)("p",null,'If you run this you will see it has "ID", "Parent" and "number_of_exons" columns. '),(0,r.kt)("p",null,"More seriously, the above code has a possible bug. (You did test it, right?) Specifically it gets\nthe answer wrong if a transcript has no exons. How did I discover this? ",(0,r.kt)("a",{target:"_blank",href:t(866).Z},"By writing a test"),".  So that needs to be fixed too.  Good luck! "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note.")," My version of the code can be found in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/whg-training/whg-training-resources/blob/main/docs/programming/programming_with_gene_annotations/solutions/part2"},"this folder")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"gene_summary.py")," file (or ",(0,r.kt)("a",{parentName:"p",href:"solutions/part2/gene_summary.py%5D"},"download directly"),"\nThe file implements both a pandas version (",(0,r.kt)("inlineCode",{parentName:"p"},"summarise_genes()"),") and a python datastructure version (",(0,r.kt)("inlineCode",{parentName:"p"},"summarise_genes_python_version()"),")."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note.")," which of these approaches do you find easier to understand? The python version of my code is definitely\nlonger, but neither seems especially simple. However, the ",(0,r.kt)("inlineCode",{parentName:"p"},"count_exons_per_transcript()")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"summarise_transcripts_per_gene()")," functions are pretty similar and so they are good candidates for a refactor - so I\nthink this code can be improved..."),(0,r.kt)("h2",{id:"a-sqlite-approach"},"A sqlite approach"),(0,r.kt)("p",null,"In the rest of this section I'll show how you could solve those problems in the sqlite database\nitself - again using data joins and group by operations."),(0,r.kt)("p",null,"First, it's convenient to make some views of the data that just reflect the genes, transcripts and\nexons:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE VIEW gene_view AS SELECT * FROM gff_data WHERE type == 'gene' ;\nCREATE VIEW transcript_view AS SELECT * FROM gff_data WHERE type == 'mRNA' ;\nCREATE VIEW exon_view AS SELECT * FROM gff_data WHERE type == 'exon' ;\n")),(0,r.kt)("p",null,"Second, to make lookups efficient, we'll also need to make sure the ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," field is indexed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE INDEX gff_data_ID_index ON gff_data( ID ) ;\n")),(0,r.kt)("p",null,"(This can take a minute or so as it builds the index)."),(0,r.kt)("p",null,"Now we can join up the data to make the counts.  First we'll count exons in transcripts:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE VIEW transcript_summary_view AS\nSELECT T.*, COUNT(E.Parent) AS number_of_exons\nFROM transcript_view T\nLEFT JOIN exon_view E ON E.Parent == T.ID\nGROUP BY T.ID;\n")),(0,r.kt)("p",null,"If you look at the result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"SELECT * FROM transcript_summary_view LIMIT 10 ;\n")),(0,r.kt)("p",null,"you'll see it takes a little while to run its computation, and it has one row per transcript, with\nthe number of exons in the last column."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note.")," As with python in principle we have to be careful what we count above. The ",(0,r.kt)("inlineCode",{parentName:"p"},"COUNT(E.Parent)")," makes sure that\nwe count only rows that correspond to an actual exon (rather than a transcript with no exons, which should get a count\nof zero. (There shouldn't really be any transcripts like this - otherwise it isn't really a transcript - but it is\nworth making sure. Are there any?)"),(0,r.kt)("p",null,"Next we can summarise transcripts for each gene:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE VIEW gene_summary_view AS\nSELECT\n    gene_view.*,\n    COUNT(T.Parent) AS number_of_transcripts,\n    CAST( SUM(number_of_exons) AS FLOAT ) / COUNT(T.ID) AS average_number_of_exons\nFROM gene_view\nLEFT JOIN transcript_summary_view T ON T.Parent == gene_view.ID\nGROUP BY gene_view.ID;\n")),(0,r.kt)("p",null,"This solves our problem:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"SELECT ID, Name, biotype, number_of_transcripts, average_number_of_exons  FROM gene_summary_view LIMIT 10;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note.")," Using ",(0,r.kt)("inlineCode",{parentName:"p"},".mode line")," or ",(0,r.kt)("inlineCode",{parentName:"p"},".mode column")," and ",(0,r.kt)("inlineCode",{parentName:"p"},".header on")," is useful in sqlite3. You can also\njust run these queries and load them into python as described above."),(0,r.kt)("p",null,"Unfortunately these queries are taking... quite a while. In fact, we are asking sqlite to do quite\na bit of work here, largely because we've built this on dynamic views of the original ",(0,r.kt)("inlineCode",{parentName:"p"},"gff_data"),"\ntable - which is very big and includes plenty that is not relevant to our query. To speed up our\nqueries (in a way that mimics what we would do in python) we can 'bake' the relevant view into\ntheir own tables first:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"CREATE TABLE genes AS SELECT analysis, ID, Parent, Name, biotype, seqid, start, end, strand FROM gene_view ;\nCREATE TABLE transcript_summary AS SELECT analysis, ID, Parent, Name, biotype, seqid, start, end, strand, number_of_exons FROM transcript_summary_view ;\nCREATE INDEX transcript_summary_Parent_INDEX ON transcript_summary( Parent ) ;\n")),(0,r.kt)("p",null,"and then rewrite ",(0,r.kt)("inlineCode",{parentName:"p"},"gene_summary_view")," to use these tables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"DROP VIEW gene_summary_view ;\nCREATE VIEW gene_summary_view AS\nSELECT\n    genes.*,\n    COUNT(T.ID) AS number_of_transcripts,\n    CAST( SUM(number_of_exons) AS FLOAT ) / COUNT(T.ID) AS average_number_of_exons\nFROM genes\nLEFT JOIN transcript_summary T ON T.Parent == genes.ID\nGROUP BY genes.ID;\n")),(0,r.kt)("p",null,"On my system, with the data above this brings query time down to a few seconds."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note.")," The ",(0,r.kt)("inlineCode",{parentName:"p"},"CAST( .. AS FLOAT )")," syntax is needed above to make sure sqlite uses floating-point arithmetic for the division."),(0,r.kt)("p",null,"Let's use this data to ",(0,r.kt)("a",{parentName:"p",href:"/whg-training-resources/programming/programming_with_gene_annotations/Counting_genes_3"},"find some extreme genes"),"."))}u.isMDXComponent=!0},2114:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/gff-6953e4a4db02bd87c9b8eae2a8a48610.py"},3563:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/gff_to_sqlite-c776051fcd5741fec1c416efbdd418da.py"},866:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/test_gff-c303bb1903bbef04e3df3bddba38f7ef.py"}}]);